<!doctype html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Kian Khayat — Articles</title>
  <link rel="stylesheet" href="styles.css"/>
</head>
<body>

<div class="topbar">
  <div class="topbarInner">
    <div class="brand">
      <div class="logo" aria-label="KT logo">KT</div>
      <div class="brandText">
        <div class="name">Kian Khayat</div>
        <div class="meta">Personal site • Portfolio • Articles</div>
      </div>
    </div>

    <nav class="navPills" aria-label="Primary">
      <a href="index.html" >Home</a>
      <a href="portfolio.html" >Portfolio</a>
      <a href="articles.html" aria-current='page'>Articles</a>
      <a href="contact.html" >Contact</a>
    </nav>

    <div class="actions">
      <button class="iconBtn" type="button" data-theme-toggle aria-label="Toggle theme">
        <span data-theme-icon></span>
      </button>
      <button class="iconBtn mobileNav" type="button" data-menu-toggle aria-label="Open menu">
        <span data-menu-icon></span>
      </button>
    </div>
  </div>

  <div class="container">
    <nav class="navPills mobileNav hidden" data-mobile-nav aria-label="Mobile">
      <a href="index.html">Home</a>
      <a href="portfolio.html">Portfolio</a>
      <a href="articles.html">Articles</a>
      <a href="contact.html">Contact</a>
    </nav>
  </div>
</div>

<div class="container">

<div class="card section">
  <div class="sectionTitle">
    <h2>Articles</h2>
    <small>Tap a topic to open the full article</small>
  </div>

  <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:12px">
    <input id="articleSearch" type="search" placeholder="Search title, tags, or summary..." style="flex:1; min-width:220px; padding:12px 14px; border-radius:16px"/>
    <select id="tagFilter" style="padding:12px 14px; border-radius:16px"></select>
  </div>

  <div id="articleList" class="articleList"></div>
</div>

<div id="articleReader" style="margin-top:16px"></div>

</div>

<div class="container">
  <div class="card footer">
    <small>© Kian Khayat.</small>
    <div class="footIcons" aria-label="Social links">
      <a href="#" aria-label="Instagram">
        <svg viewBox="0 0 24 24"><path d="M7 7h10v10H7z"/><path d="M16 3H8a5 5 0 0 0-5 5v8a5 5 0 0 0 5 5h8a5 5 0 0 0 5-5V8a5 5 0 0 0-5-5Z"/><path d="M16.5 7.5h.01"/></svg>
      </a>
      <a href="#" aria-label="Telegram">
        <svg viewBox="0 0 24 24"><path d="M22 2 11 13"/><path d="M22 2 15 22l-4-9-9-4 20-7Z"/></svg>
      </a>
      <a href="#" aria-label="WhatsApp">
        <svg viewBox="0 0 24 24"><path d="M20 11.5a8.5 8.5 0 0 1-12.6 7.4L4 20l1.2-3.3A8.5 8.5 0 1 1 20 11.5Z"/><path d="M8.5 9.5c1.5 3 3 4.5 6 6"/><path d="M14.5 15.5l2-1"/></svg>
      </a>
      <a href="#" aria-label="LinkedIn">
        <svg viewBox="0 0 24 24"><path d="M4 9h4v11H4z"/><path d="M6 4a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z"/><path d="M10 9h4v2"/><path d="M14 11c1-1 2-2 4-2 3 0 4 2 4 5v6h-4v-5c0-2 0-3-2-3s-2 1-2 3v5h-4z"/></svg>
      </a>
    </div>
  </div>
</div>

<script src="app.js"></script>
<script>window.__ARTICLES__ = [{"id": "cpu-pipelines", "title": "How Modern CPUs Really Execute Code: Pipelines, Caches, and Speculation", "summary": "A practical mental model of how instructions flow through a CPU, why caches matter more than clock speed, and what speculation changes.", "tags": ["CPU", "Architecture", "Performance"], "meta": "~8 min read \u2022 Computer Architecture", "body": ["Most people meet a CPU as a single number: \u201c3.6 GHz.\u201d It\u2019s tempting to imagine a tiny worker inside your laptop that reads one instruction, finishes it, then starts the next one. Real CPUs are closer to a factory line. They try to keep many parts of many instructions in flight at the same time. The goal is not to make one instruction incredibly fast, but to keep the hardware busy every cycle so that, on average, work is completed continuously. This is the idea behind pipelining: split the work into stages (fetch, decode, execute, memory, write-back) and overlap those stages across different instructions.", "In a perfect world, a pipeline produces one completed instruction per cycle. The problem is that code isn\u2019t perfectly predictable. Branches (if/else), dependencies (an instruction needs the result of the previous one), and memory delays constantly interrupt the flow. Modern CPUs fight this with two big ideas: out-of-order execution and speculation. Out-of-order execution means the CPU can temporarily rearrange the order of operations, as long as it preserves the final program behavior. If instruction A is waiting for data from memory, the CPU might execute independent instruction B and C while A stalls, then come back to A when the data arrives. This is why \u201cinstruction-level parallelism\u201d matters: code with independent work lets the CPU stay busy.", "Memory is the next huge bottleneck. A CPU cycle is incredibly short compared to a trip to main memory (RAM). If the CPU had to wait for RAM every time, it would spend most of its life idle. Caches fix this by keeping recently used data close to the CPU in small, fast memory levels (L1, L2, L3). Your program\u2019s speed often depends less on raw compute and more on whether your data is in cache. That\u2019s why iterating a large array sequentially is usually fast (good locality) while jumping around randomly can be slow (cache misses).", "Branches break pipelines because the CPU doesn\u2019t know which path you\u2019ll take until the branch condition is evaluated. Speculation is the CPU\u2019s \u201cbetting system.\u201d It predicts which way a branch will go (branch predictor), and it starts executing down that predicted path before the decision is confirmed. If the prediction is right, you saved time. If it\u2019s wrong, the CPU throws away speculative work and pays a penalty. That\u2019s why \u201cunpredictable branches\u201d can be expensive, and why sometimes replacing branches with arithmetic or lookup tables helps.", "A useful takeaway is that performance is about feeding the machine. Make memory access patterns predictable, keep hot data small enough for caches, and reduce unpredictable branches. This doesn\u2019t mean you always micro-optimize. But it does mean that when code is slow, you should ask: is it compute-bound, memory-bound, or branch-bound? Profilers can help you find which. Once you know the bottleneck, the fixes become more obvious: improve locality, avoid unnecessary allocations, batch work, or simplify branching. That\u2019s the real \u201cmodern CPU mental model\u201d: not a single number, but a pipeline that hates waiting."]}, {"id": "fft-guide", "title": "From Noise to Insight: A Gentle Guide to Signal Processing and the FFT", "summary": "Understand signals, frequency-domain thinking, and why the FFT is one of the most useful algorithms in engineering.", "tags": ["Signals", "Math", "FFT"], "meta": "~9 min read \u2022 Signal Processing", "body": ["Signal processing sounds intimidating until you realize it\u2019s basically a language for describing change over time. A \u201csignal\u201d can be audio, sensor readings, network traffic, or stock prices. In the time domain you look at values as they evolve: a waveform, a trend, spikes, noise. But sometimes the time view hides structure. A sound might look messy, yet it\u2019s built from a few dominant frequencies. That\u2019s where the frequency domain becomes powerful: it tells you which repeating patterns (frequencies) are present, and how strong they are.", "The Fourier Transform is the bridge. It expresses a signal as a sum of sine and cosine waves. You can think of it as asking a big set of questions: \u201cHow much of frequency f is in this signal?\u201d for many values of f. If a signal contains a 440 Hz tone (the A above middle C), the Fourier Transform will show a strong peak around 440 Hz. If the signal contains harmonics, you\u2019ll see peaks at multiples. If it\u2019s mostly noise, energy spreads more evenly.", "Digital signals are sampled, so we typically use the Discrete Fourier Transform (DFT). The DFT takes N samples and produces N frequency bins. But a direct DFT is slow: O(N\u00b2) operations. The Fast Fourier Transform (FFT) is a clever family of algorithms that compute the same result in O(N log N). That speedup is why FFTs appear everywhere: audio equalizers, image compression, wireless communication, vibration analysis, and even multiplying big integers.", "There are a few practical details that matter. First is sampling rate. The highest frequency you can represent is half the sampling rate (the Nyquist limit). If you sample too slowly, higher frequencies \u201cfold\u201d into lower ones, creating aliasing. This is why audio is often sampled at 44.1 kHz: it can represent frequencies up to ~22 kHz, slightly above the range of human hearing. Second is windowing. If you take a short chunk of a longer signal, you are implicitly cutting it off. That sharp cut introduces spectral leakage, smearing energy across frequencies. Using a window function (like Hann) smooths edges and produces cleaner spectra.", "Finally, frequency thinking helps you design filters. If you want to remove hum at 50/60 Hz, you can design a notch filter. If you want to smooth sensor noise, a low-pass filter keeps slow changes and removes rapid fluctuations. Many filters can be built in the time domain, but understanding their frequency behavior gives intuition: every filter has a \u201cfrequency response\u201d that describes which frequencies pass and which are attenuated.", "The big idea: the FFT is not just a math trick; it\u2019s a perspective shift. It lets you find structure in what looks like chaos. Once you get comfortable moving between time and frequency, you start seeing problems differently. You stop asking only \u201cwhat happened over time?\u201d and also ask \u201cwhat patterns are inside this signal?\u201d That\u2019s the moment signal processing becomes a superpower."]}];</script>
</body>
</html>
